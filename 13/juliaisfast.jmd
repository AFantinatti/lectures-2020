# Julia is fast

Very often, benchmarks are used to compare languages. These benchmarks can lead to long discussions, first as to exactly what is being benchmarked and secondly what explains the differences. These simple questions can sometimes get more complicated than you at first might imagine.

The purpose of this notebook is for you to see a simple benchmark for yourself.

(This material began life as a wonderful lecture by Steven Johnson at MIT: [https://github.com/stevengj/18S096/blob/master/lectures/lecture1/Boxes-and-registers.ipynb]().)


## Outline of this notebook

- Define the sum function
- Implementations & benchmarking of sum in...
  - C (hand-written)
  - C (hand-written with -ffast-math)
  - python (built-in)
  - python (numpy)
  - python (hand-written)
  - Julia (built-in)
  - Julia (hand-written)
  - Julia (hand-written with SIMD)
- Summary of benchmarks

## sum: An easy enough function to understand
Consider the sum function `sum(a)`, which computes
$$
\mathrm{sum}(a)=\sum_{i=1}^n a_i,
$$
where $n$ is the length of $a$.

```julia
a = rand(10^7) # 1D vector of random numbers, uniform on [0,1)
```

```julia
sum(a)
```

The expected result is `0.5 * 10^7`, since the mean of each entry is `0.5`.

## Benchmarking a few ways in a few languages
```julia
@time sum(a)
```

```julia
@time sum(a)
```

```julia
@time sum(a)
```

The `@time` macro can yield noisy results, so it's not our best choice for benchmarking!

Luckily, Julia has a `BenchmarkTools.jl` package to make benchmarking easy and accurate:

```julia
using BenchmarkTools
```

### The C language

C is often considered the gold standard: difficult on the human, nice for the machine. Getting within a factor of 2 of C is often satisfying. Nonetheless, even within C, there are many kinds of optimizations possible that a naive C writer may or may not get the advantage of.

The current author does not speak C, so he does not read the cell below, but is happy to know that you can put C code in a Julia session, compile it, and run it. Note that the `"""` wrap a multi-line string.

```julia
using Libdl
C_code = """
#include <stddef.h>
double c_sum(size_t n, double *X) {
    double s = 0.0;
    for (size_t i = 0; i < n; ++i) {
        s += X[i];
    }
    return s;
}
"""

const Clib      = tempname()   # make a temporary file


# compile to a shared library by piping C_code to gcc
# (works only if you have gcc installed):

open(`gcc -fPIC -O3 -mavx2 -xc -shared -o $(Clib * "." * Libdl.dlext) -`, "w") do f
    print(f, C_code)
end

# define a Julia function that calls the C function:
c_sum(X::Array{Float64}) = ccall(("c_sum", Clib), Float64, (Csize_t, Ptr{Float64}), length(X), X)
```

```julia
@show c_sum(a)
```

```julia
c_sum(a) ≈ sum(a) # type \approx and then <TAB> to get the ≈ symbolb
```

```julia
c_sum(a) - sum(a)
```

```julia
≈  # alias for the `isapprox` function
```

#### Examples
```julia
0.1 ≈ (0.1 - 1e-10)
```
```julia
isapprox(10, 11; atol = 2)
```
```julia
isapprox([10.0^9, 1.0], [10.0^9, 2.0])
```
```julia
1e-10 ≈ 0
```
```julia
isapprox(1e-10, 0, atol=1e-8)
```
We can now benchmark the C code directly from Julia:

```julia
c_bench = @benchmark c_sum($a)
```

We'll collect all the results in a dictionary
```julia
d = Dict()  # a "dictionary", i.e. an associative array
d["C"] = minimum(c_bench.times) / 1e6  # in milliseconds
d
```

It's worth noting that benchmarking on a computer can be tricky as can been seen
from a histogram of the timings
```julia
using Plots
histogram(c_bench.times/1000^2, bins=100,
    xlabel="milliseconds", ylabel="count", label="")
```

### C with -ffast-math

If we allow C to re-arrange the floating point operations, then it'll vectorize with SIMD (single instruction, multiple data) instructions.

```julia
const Clib_fastmath = tempname()   # make a temporary file

# The same as above but with a -ffast-math flag added
open(`gcc -fPIC -O3 -march=native -xc -shared -ffast-math -o $(Clib_fastmath * "." * Libdl.dlext) -`, "w") do f
    print(f, C_code)
end

# define a Julia function that calls the C function:
c_sum_fastmath(X::Array{Float64}) = ccall(("c_sum", Clib_fastmath), Float64, (Csize_t, Ptr{Float64}), length(X), X)
```

```julia
c_fastmath_bench = @benchmark $c_sum_fastmath($a)
```

```julia
d["C -ffast-math"] = minimum(c_fastmath_bench.times) / 1e6  # in milliseconds
```

### Python's built in sum
The `PyCall` package provides a Julia interface to Python:

```julia
# using Pkg; Pkg.add("PyCall")
using PyCall
```

We can create a Julia function which points to the Python built-in "sum" function:
```julia
pysum = pybuiltin("sum")
```

```julia
pysum(a) ≈ sum(a)
```

```julia
py_list_bench = @benchmark $pysum($a)
```

```julia
d["Python built-in"] = minimum(py_list_bench.times) / 1e6
d
```

### Python: numpy

Takes advantage of hardware "SIMD", but only works when it works.

`numpy` is an optimized C library, callable from Python. It may be installed within Julia as follows:

```julia
# using Pkg; Pkg.add("Conda")
using Conda
# Conda.add("numpy")
```

```julia
numpy_sum = pyimport("numpy").sum

py_numpy_bench = @benchmark $numpy_sum($a)
```

```julia
numpy_sum(a) ≈ sum(a)
```

```julia
d["Python numpy"] = minimum(py_numpy_bench.times) / 1e6
d
```

### Python, hand-written
```julia
py"""
def py_sum(A):
    s = 0.0
    for a in A:
        s += a
    return s
"""

sum_py = py"py_sum"
```

```julia
py_hand = @benchmark $sum_py($a)
```

```julia
sum_py(a) ≈ sum(a)
```

```julia
d["Python hand-written"] = minimum(py_hand.times) / 1e6
d
```

### R (built-in)

```julia
using RCall
sum_R(a) = R"sum($a)"
```

```julia
r_bench = @benchmark $sum_R($a)
```

```julia
d["R built-in"] = minimum(r_bench.times) / 1e6
d
```

### R (hand-written)

```julia
mysum_R(a) = R"""
mysum <- function(a) {
  s = 0.0
  for (i in 1:length(a)) {
    s = s + a[i]
  }
  return(s)
}
mysum($a)
"""
```

```julia
r_hand_bench = @benchmark $mysum_R($a)
```

```julia
d["R hand-written"] = minimum(r_hand_bench.times) / 1e6
d
```

### Julia (built-in)

Written directly in Julia, not in C!

```julia
@which sum(a)
```

```julia
j_bench = @benchmark sum($a)
```

```julia
d["Julia built-in"] = minimum(j_bench.times) / 1e6
d
```


### Julia (hand-written)
```julia
function mysum(A)
    s = 0.0 # s = zero(eltype(a))
    for a in A
        s += a
    end
    s
end
```

```julia
j_bench_hand = @benchmark mysum($a)
```

```julia
mysum(a) ≈ sum(a)
```

```julia
d["Julia hand-written"] = minimum(j_bench_hand.times) / 1e6
d
```

 ### Julia (hand-written w. simd)

```julia
function mysum_simd(A)
    s = 0.0 # s = zero(eltype(A))
    @simd for a in A
        s += a
    end
    s
end
```

```julia
j_bench_hand_simd = @benchmark mysum_simd($a)
```

```julia
mysum_simd(a) ≈ sum(a)
```

```julia
d["Julia hand-written simd"] = minimum(j_bench_hand_simd.times) / 1e6
d
```

## Summary
```julia
for (key, value) in sort(collect(d), by=last)
    println(rpad(key, 25, "."), lpad(round(value; digits=1), 6, "."))
end
```
